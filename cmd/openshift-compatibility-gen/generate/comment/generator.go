package comment

import (
	"bytes"
	"fmt"
	"go/parser"
	"go/token"
	"io/ioutil"
	"os"
	"os/exec"
	"regexp"
	"strconv"
	"strings"

	"github.com/dave/dst"
	"github.com/dave/dst/decorator"
	"github.com/dave/dst/dstutil"
	"k8s.io/klog/v2"
)

// GenerateCompatibilityComments add a compatibility level comment to instrumented types.
func GenerateCompatibilityComments(inputPkgs []string) error {
	for _, inputPkg := range inputPkgs {
		output, err := exec.Command("go", "list", "-f", "{{ .Dir }}", inputPkg).Output()
		if err != nil {
			klog.Errorf(string(output))
			return err
		}
		path := string(output)
		path = strings.TrimSpace(path)
		insertCompatibilityLevelComments(path)
	}
	return nil
}

func insertCompatibilityLevelComments(path string) {
	pkgs, err := decorator.ParseDir(token.NewFileSet(), path, onlyTypesFiles, parser.ParseComments)
	if err != nil {
		klog.Exit(err)
	}
	for _, pkg := range pkgs {
		processPackage(pkg)
	}
}

// onlyTypesFiles returns true if there is a reasonable chance the file contain type definitions
func onlyTypesFiles(info os.FileInfo) bool {
	if strings.HasPrefix("zz_generated", info.Name()) {
		return false
	}
	switch info.Name() {
	case "doc.go", "register.go", "generated.pb.go":
		return false
	}
	return true
}

// processPackage processes all the files in a package
func processPackage(pkg *dst.Package) {
	for fileName, file := range pkg.Files {
		fileChanged := processFile(file)
		if !fileChanged {
			continue
		}
		removeIgnoreAutogeneratedBuildTag(file)
		var buf bytes.Buffer
		if err := decorator.Fprint(&buf, file); err != nil {
			panic(err)
		}
		if err := ioutil.WriteFile(fileName, buf.Bytes(), 0777); err != nil {
			panic(err)
		}
	}
}

// removeIgnoreAutogeneratedBuildTag removes the `// +build !ignore_autogenerated` build tag that
// somehow gets added to the generated file.
func removeIgnoreAutogeneratedBuildTag(file *dst.File) {
	if len(file.Decls) > 0 {
		end := file.Decls[len(file.Decls)-1].Decorations().End
		if len(end.All()) > 0 {
			var filtered []string
			for _, comment := range end.All() {
				if comment != "// +build !ignore_autogenerated" {
					filtered = append(filtered, comment)
				}
			}
			file.Decls[len(file.Decls)-1].Decorations().End.Replace(filtered...)
		}
	}
}

// processFile adds compatibility level comments to a file
func processFile(f *dst.File) bool {
	g := compatibilityLevelCommentGenerator{}
	dstutil.Apply(f, g.applyCompatibilityLevelComment(), nil)
	return g.changed
}

// compatibilityLevelCommentGenerator provides an ApplyFunc for dst.Apply() and knows if
// the ApplyFunc actually changed the source code.
type compatibilityLevelCommentGenerator struct {
	changed bool
}

// applyCompatibilityLevelComment returns an ApplyFunc that inserts compatibility level comments.
func (g *compatibilityLevelCommentGenerator) applyCompatibilityLevelComment() dstutil.ApplyFunc {
	return func(c *dstutil.Cursor) bool {

		genDecl, ok := c.Node().(*dst.GenDecl)
		if !ok {
			return true
		}
		// we have a generic declaration

		if genDecl.Tok != token.TYPE {
			return true
		}
		// we have a type declaration

		typeSpec := genDecl.Specs[0].(*dst.TypeSpec)
		_, ok = typeSpec.Type.(*dst.StructType)
		if !ok {
			return true
		}
		// we have a struct type declaration

		klog.V(5).Infof("Checking %v...", typeSpec.Name.Name)
		klog.V(5).Infof("\tBefore: %v", genDecl.Decorations().Before.String())
		klog.V(5).Infof("\tAfter : %v", genDecl.Decorations().After.String())
		klog.V(5).Infof("\tStart : %#v", genDecl.Decorations().Start.All())
		klog.V(5).Infof("\tEnd   : %#v", genDecl.Decorations().End.All())

		tag, ok := getCompatibilityLevelTag(genDecl)
		if !ok {
			return true
		}
		// we have a compatibility level tag
		klog.V(5).Infof("\tTag   : %v", tag)

		// add/edit comments as needed
		changed := ensureCompatibilityLevelComment(genDecl, tag)
		if changed {
			g.changed = true
		}

		// continue to process nodes
		return true
	}
}

// ensureCompatibilityLevelComment either replaces a stale compatibility level comment, or adds a new one.
func ensureCompatibilityLevelComment(genDecl *dst.GenDecl, tag string) bool {
	// copy of existing comments we can manipulate
	comments := append([]string{}, genDecl.Decorations().Start.All()...)

	level := extractLevelFromComment(tag)
	newComment := fmt.Sprintf("// Compatibility level %d: %s", level, commentForLevel(level))

	// if there is already a compatibility comment, replace if needed
	for i, existingComment := range comments {
		switch {
		case existingComment == newComment:
			return false
		case strings.HasPrefix(existingComment, "// Compatibility level "):
			comments[i] = newComment
			genDecl.Decorations().Start.Replace(comments...)
			return true
		}
	}

	// no existing compatibility comment, find a nice place to add one
	insertIndex := len(comments)
l:
	for i := len(comments) - 1; i >= 0; i-- {
		switch {
		case strings.HasPrefix(comments[i], "// +"):
			insertIndex = i
		case comments[i] == "\n":
			// in order to show up in the godoc, comment must be adjacent to declaration
			break l
		}
	}

	// surround with empty ('//') comments if needed to ensure godoc paragraph breaks
	newComments := []string{
		newComment,
	}
	switch {
	case insertIndex == 0:
	case comments[insertIndex-1] == "\n":
	case comments[insertIndex-1] == "// ":
	default:
		newComments = append([]string{"// "}, newComments...)
	}
	switch {
	case insertIndex == len(comments):
	case comments[insertIndex] == "\n":
	case comments[insertIndex] == "// ":
	default:
		newComments = append(newComments, "// ")
	}

	// insert comments
	comments = append(comments[:insertIndex], append(newComments, comments[insertIndex:]...)...)
	genDecl.Decorations().Start.Replace(comments...)

	return true
}

func getCompatibilityLevelTag(genDecl *dst.GenDecl) (string, bool) {
	re := regexp.MustCompile(`\s*//\s*\+(openshift:compatibility-gen:level=.*)`)
	for _, comment := range genDecl.Decorations().Start.All() {
		if re.MatchString(comment) {
			a := re.FindAllStringSubmatch(comment, -1)[0][1]
			return a, true
		}
	}
	return "", false
}

func commentForLevel(level int) string {
	switch level {
	case 1:
		return "Stable within a major release for a minimum of 12 months or 3 minor releases (whichever is longer)."
	case 2:
		return "Stable within a major release for a minimum of 9 months or 3 minor releases (whichever is longer)."
	case 3:
		return "Will attempt to be as compatible from version to version as possible, but version to version compatibility is not guaranteed."
	case 4:
		return "No compatibility is provided, the API can change at any point for any reason. These capabilities should not be used by applications needing long term support."
	default:
		panic(level)
	}
}

func extractLevelFromComment(c string) int {
	p := strings.Split(c, "=")
	if len(p) != 2 {
		klog.Exitf("Could not successfully parse comment tag %s: expected exactly one '='", c)
	}
	level, err := strconv.Atoi(p[1])
	if err != nil {
		klog.Exitf("Could not successfully parse comment tag %s: %v", c, err)
	}
	if level < 1 || level > 4 {
		klog.Exitf("Could not successfully parse comment tag %s: level must be one of 1, 2, 3, or 4", c)
	}
	return level
}
